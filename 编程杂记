1：对于C++各种数据类型，切记在声明变量时应该对该变量进行初始化，否则在下面使用过程中可能直接出现 a+=10 的情况，此时a的值是未定义的；
2：向上取整：ceil（） 向下取整：floor() ；
3：对于某些设计整数运算特别是大整数进行乘法或者阶乘类似的运算时，可能采取的方案：
   a）：采用位数更大的数据结构如：int -> long -> long long
   b）：对于采用乘法进行大数比较时考虑采用除法的形式进行，但此时可能出现浮点数（不能整除的情况）
   参考LeetCode.400
4：浮点数比较不同于整数类型的比较 一般为double a，b比较：bool（abs(a-b)<10E-6）即可认为两个浮点数的值是相等的，
   具体的参数（此题6）视操作系统的情况而定。
5：对于排座位或者种花的问题因为考虑到边界问题，也就是对于边界问题需要额外考虑，此时边界情况可能比较复杂，
   应考虑在算法预处理阶段对数据进行处理以统一标准可以用统一的标准去处理，参考LeetCode.605 2017年06月08日
6：待解决关于类的问题：LeetCode.303 为什么利用拷贝的构造函数的结果与别人的在构造函数中使用部分和概念的结果差这么多？09时51分32秒
   思考结果：在每次的查询过程中的消耗时间是时间复杂度较高的原因，在此区别：对于单次查询这种方法是最优的，但是当查询次数变多时，
   推荐使用类似于二次查表的方法，达到一次建表多次查询，以“空间换时间”的做法，此题更优因为将数据矩阵替换为了查表矩阵。
7:对于编码类型的题目，应该特别注意以下边界条件：
   a）: 进制发生进位的时候
   b）：零是如何处理的
  还有就是进制的数目到底是几进制的数据。
8:关于素数的问题：单个数字x判断是否是素数一般采用2～sqrt(x)循环判断是否整除；但对于类似小于x的所有素数的算法，
  不适合利用此种方法进行解决，时间复杂度过高，有一类类似穷举遍历的算法，对于所有的定义域空间无法一一判断合理性时，
  可以考虑在解空间中进行排除、筛选等，以在解空间中把问题解决。
 （定义域无法遍历或者遍历太困难时，解空间有遍历的方法或者维度或数量级上较小时可以考虑）。
9:许多类似于搜索的问题都应该想到利用已经学过的工程优化的知识：
   a)：单调函数或者阶跃函数类型一般采取二分法；
   b): 类似于抛物线形的函数应该采取进退搜索法；
   c): 对于多维度函数求解可考虑最速下降法；
   d): 还有很多最新的新兴元搜索算法，类似于蚁群算法，布谷鸟算法，粒子群等。
10：void 指针可以用来指向任何类型的数据，但是void指针不能用来初始化任何类型的指针，即使类型的型别与空指针现在绑定的类型一致也不行。
11：const 成员函数不能改变类内部的任何非static成员变量，同时const函数返回的一般也是const引用类型的数据或者也可以返回一般的值类型，因为此时如果是
引用类型所绑定的数据依旧是const，所以不能隐式地将该数据的const属性去掉。
12：const成员属性默认有两种观点：
   a)：const 成员函数不能改变当前类的非静态成员函数中的任何一个bite，而且编译器一般也是这样来检查的；
   b)：const成员函数可以更改当前类的某些bite，但是对于当前类中的资源类型是不能更改的，为了越过编译器的检查
       可以利用C++提供的 mutable 来修饰我们可能要改变的成员变量；
13：编译器不会为已经定义了自己的构造器的类隐含定义一个默认构造器，因为如果有一个构造器的参数全部是默认参数，
    编译器自己合成的构造器会和这个默认的构造器产生调用二义性。
14：运算符重载必须保证传入的参数不能全部为内置类型，其传入参数必须含有一个类类型的数据；
    运算符重载一般是类成员函数，或者非类成员函数（友元函数居多），常用规则如下：
    a）：赋值（=），下表（[]），调用（（））和成员访问符（->）必须为类内成员函数。
    b）：复合赋值运算符一般是类成员函数，但并非必须
    c）：改变对象的状态的运算符一般是类成员函数，例如：自增，自减，接引用等
    d）：具有对称原则的运算符，例如：算数运算符（+ - * /）,相等性，关系和位运算符，这些一般都是非成员函数
15：运算符一般重载形式：typename T
    1）：非成员函数（友元函数居多）：输出运算符（<<）: ostream& operator<<(ostream& os,const T& t) 尽量减少对格式的控制，
         如有需要，使用者会自行添加
    2）：非成员函数（友元函数居多）：输入运算符（>>）: istream& operator>>(istream& is,T& t) 一般在函数内部需要检查流的状态
    3）：非成员函数（友元函数居多）：加法运算符（+） : T t operator+(const T &t1,const T &t2) 一般也应该生成一个复合的+=运算
        符，不过一般是利用+=来实现+
    4）：非成员函数（友元函数居多）：相等运算符（==）：bool operator==(const T &t1,const T &t2) 不等运算符！=格式与此相同，
        一般利用==运算符来实现
    5）：成员函数：赋值运算符：赋值运算符一般可以概括为以下三类：
         拷贝赋值操作符：T &t operator=(const T& t)
         移动赋值操作符：T &t operator=(T && t)
         初始化列表赋值：T &t operator=(std::initializer_list<type_of_t>)
         由于以上赋值相关操作需要改变调用对象的内容，所以返回引用类型数据，同时引用类型数据也可以解决连续赋值的问题；
         赋值操作应该注意自赋值的问题，一般需要先对右侧运算对象进行赋值，然后再对左对象进行析构，最后将右值赋到左值的对应成员变量上
         且对于拷贝和移动赋值操作应该与对应的拷贝构造和移动构造函数结合起来，加深理解。
     6): 成员函数：复合赋值运算符（以+=为例）由于复合赋值运算符中需要进行赋值操作，所以其行为表现的更像是一个赋值类型，
         所以其定义结构及形式更像赋值相关运算符：T& t operator+=(const T& t) 其中复合赋值运算符的左值绑定到调用对象的this指针上
     7): 必须为成员运算符：下标运算符[],由于是读取操作而且必须为成员函数，所以存在两个版本普通版本和常亮版本
         普通版本：typeofT& tot operator[](size_t st)
         常量版本：const typeofT& tot operator[](size_t st)const
     8): 建议成员函数 递增，递减运算符（++，--）由于需要改变运算对象的值所以一般建议设定为成员函数运算符
         前置自增：T& t operator++( )    后置自增：T t operator++(int)
         前置自减：T& t operator--( )    后置自减：T t operator--(int)
         后置版本中int形参函数体中并不会使用，用来与前置版本分开来，很像STL标准库中根据迭代器的类型进行重载的行为
         一般后置版本的运算符会调用前置版本的函数内容。前置运算，先运算后输出；后置运算符，先输出后运算
         为了与内置的运算符保持一致，前置版本的返回对应对象的引用，后置对象返回一个对象值而非引用
         记忆技巧：int在后就是后置版的++或--，屁事多的都是后置的，而且后置的还得依赖前置的版本
      9): 成员函数：成员访问运算符（->）一般是迭代器类型或者是智能指针一类的类会定义这种类型的成员访问函数,此时T应该是一个迭代器
          或者指针类型                                                    
          解引用运算符：Tpointed& operator*()       成员访问运算符:  Tpointed* operator->(){return &(operator*());}
          重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。
