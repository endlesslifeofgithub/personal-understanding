1：对于C++各种数据类型，切记在声明变量时应该对该变量进行初始化，否则在下面使用过程中可能直接出现 a+=10 的情况，此时a的值是未定义的；
2：向上取整：ceil（） 向下取整：floor() ；
3：对于某些设计整数运算特别是大整数进行乘法或者阶乘类似的运算时，可能采取的方案：
   a）：采用位数更大的数据结构如：int -> long -> long long
   b）：对于采用乘法进行大数比较时考虑采用除法的形式进行，但此时可能出现浮点数（不能整除的情况）
   参考LeetCode.400
4：浮点数比较不同于整数类型的比较 一般为double a，b比较：bool（abs(a-b)<10E-6）即可认为两个浮点数的值是相等的，具体的6 视操作系统的情况而定。
5:对于排座位或者种花的问题因为考虑到边界问题，也就是对于边界问题需要额外考虑，此时边界情况可能比较复杂，应考虑在算法预处理阶段对数据进行处理以统一标准可以用统一的标准去处理，参考LeetCode.605 2017年06月08日
6：待解决关于类的问题：LeetCode.303 为什么利用拷贝的构造函数的结果与别人的在构造函数中使用部分和概念的结果差这么多？09时51分32秒  结果，在每次的查询过程中的消耗时间是时间复杂度较高的原因，在此区别：对于单次查询这种方法是最优的，但是当查询次数变多时，推荐使用类似于二次查表的方法，达到一次建表多次查询，以“空间换时间”的做法，此题更优因为将数据矩阵替换为了查表矩阵。  
7:对于编码类型的题目，应该特别注意以下边界条件：
			a）：进制发生进位的时候
			b）：零是如何处理的
  还有就是进制的数目到底是几进制的数据。    
8:关于素数的问题：单个数字x判断是否是素数一般采用2～sqrt(x)循环判断是否整除；但对于类似小于x的所有素数的算法，不适合利用此种方法进行解决，时间复杂度过高，有一类类似穷举遍历的算法，对于所有的定义域空间无法一一判断合理性时，可以考虑在解空间中进行排除、筛选等，以在解空间中把问题解决。（定义域无法遍历或者遍历太困难时，解空间有遍历的方法或者维度或数量级上较小时可以考虑）。
9:许多类似于搜索的问题都应该想到利用已经学过的工程优化的知识：
  a)：单调函数或者阶跃函数类型一般采取二分法；
  b): 类似于抛物线形的函数应该采取进退搜索法；
  c): 对于多维度函数求解可考虑最速下降法；
  d): 还有很多最新的新兴元搜索算法，类似于蚁群算法，布谷鸟算法，粒子群等。
